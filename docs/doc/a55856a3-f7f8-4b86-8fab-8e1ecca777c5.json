{
    "summary": "The VideoLoader executor class manages video extraction, audio parameters, and error handling using FFmpeg while processing subtitles in .srt or .vtt format.",
    "details": [
        {
            "comment": "The code snippet is part of a VideoLoader executor class. It imports necessary libraries, sets default values for FPS, audio bit rate, channels, and sampling rate. The executor's main purpose is to extract image frames, audio, and text from videos using `ffmpeg`. The class has optional parameters for modifying the ffmpeg arguments, allowing customization of video, audio, and subtitle arguments.",
            "location": "\"/media/root/Prima/works/vced/docs/src/code/service/videoLoader/video_loader.py\":0-43",
            "content": "__copyright__ = \"Copyright (c) 2020-2021 Jina AI Limited. All rights reserved.\"\n__license__ = \"Apache-2.0\"\nimport io\nimport os\nimport random\nimport re\nimport string\nimport tempfile\nimport urllib.request\nimport urllib.parse\nfrom copy import deepcopy\nfrom typing import Dict, Iterable, Optional\nfrom pathlib import Path\nimport ffmpeg\nimport librosa\nimport numpy as np\nimport webvtt\nfrom jina import Executor, requests\nfrom docarray import Document, DocumentArray\nfrom jina.logging.logger import JinaLogger\nfrom PIL import Image\nimport math\nimport time\nDEFAULT_FPS = 1.0\nDEFAULT_AUDIO_BIT_RATE = 160000\nDEFAULT_AUDIO_CHANNELS = 2\nDEFAULT_AUDIO_SAMPLING_RATE = 44100  # Hz\nDEFAULT_SUBTITLE_MAP = '0:s:0'\nclass VideoLoader(Executor):\n    \"\"\"\n    An executor to extract the image frames, audio from videos with `ffmpeg`.\n    \"\"\"\n    def __init__(\n        self,\n        modality_list: Iterable[str] = ('image', 'audio', 'text'),\n        ffmpeg_video_args: Optional[Dict] = None,\n        ffmpeg_audio_args: Optional[Dict] = None,\n        ffmpeg_subtitle_args: Optional[Dict] = None,"
        },
        {
            "comment": "This code defines a function that extracts data from different modalities such as images and audio from a video file using the ffmpeg library. It takes optional arguments for specifications like modality_list, ffmpeg_video_args, ffmpeg_audio_args, and ffmpeg_subtitle_args to customize the extraction process. The default settings include extracting both image frames and audio tracks with certain format specifications.",
            "location": "\"/media/root/Prima/works/vced/docs/src/code/service/videoLoader/video_loader.py\":44-57",
            "content": "        librosa_load_args: Optional[Dict] = None,\n        copy_uri: bool = True,\n        **kwargs,\n    ):\n        \"\"\"\n        :param modality_list: the data from different modalities to be extracted. By default,\n            `modality_list=('image', 'audio')`, both image frames and audio track are extracted.\n        :param ffmpeg_video_args: the arguments to `ffmpeg` for extracting frames. By default, `format='rawvideo'`,\n            `pix_fmt='rgb24`, `frame_pts=True`, `vsync=0`, `vf=[FPS]`, where the frame per second(FPS)=1. The width and\n            the height of the extracted frames are the same as the original video. To reset width=960 and height=540,\n            use `ffmpeg_video_args={'s': '960x540'`}.\n        :param ffmpeg_audio_args: the arguments to `ffmpeg` for extracting audios. By default, the bit rate of the audio\n             `ab=160000`, the number of channels `ac=2`, the sampling rate `ar=44100`\n        :param ffmpeg_subtitle_args: the arguments to `ffmpeg` for extracting subtitle. By default, we extract the first"
        },
        {
            "comment": "This function initializes the VideoLoader class and sets its properties. It takes in various arguments such as modality, ffmpeg_video_args, librosa_load_args, and copy_uri. The default value of copy_uri is True which means that if set to True, the video uri will be stored at .tags['video_uri'] of the chunks extracted from the video. It also sets default values for ffmpeg_video_args such as format='rawvideo', pix_fmt='rgb24', and frame_pts=True.",
            "location": "\"/media/root/Prima/works/vced/docs/src/code/service/videoLoader/video_loader.py\":58-72",
            "content": "            subtitle by setting `map='0:s:0'`. To extract second subtitle in a video use\n            `ffmpeg_subtitle_args{map='0:s:1'}` and so on.\n        :param librosa_load_args: the arguments to `librosa.load()` for converting audio data into `tensor`. By default,\n            the sampling rate (`sr`) is the same as in `ffmpeg_audio_args['ar']`, the flag for converting to mono\n            (`mono`) is `True` when `ffmpeg_audio_args['ac'] > 1`\n        :param copy_uri: Set to `True` to store the video `uri` at the `.tags['video_uri']` of the chunks that are\n            extracted from the video. By default, `copy_uri=True`. Set this to `False` when the video uri is a data uri.\n        \"\"\"\n        super().__init__(**kwargs)\n        self._modality = modality_list\n        self._copy_uri = copy_uri\n        self._ffmpeg_video_args = ffmpeg_video_args or {}\n        self._ffmpeg_video_args.setdefault('format', 'rawvideo')\n        self._ffmpeg_video_args.setdefault('pix_fmt', 'rgb24')\n        self._ffmpeg_video_args.setdefault('frame_pts', True)"
        },
        {
            "comment": "The code initializes default audio and video arguments for ffmpeg, retrieves the frame rate if available, sets up audio and subtitle loading parameters, and creates a logger.",
            "location": "\"/media/root/Prima/works/vced/docs/src/code/service/videoLoader/video_loader.py\":73-91",
            "content": "        self._ffmpeg_video_args.setdefault('vsync', 0)\n        self._ffmpeg_video_args.setdefault('vf', f'fps={DEFAULT_FPS}')\n        fps = re.findall(r'.*fps=(\\d+(?:\\.\\d+)?).*', self._ffmpeg_video_args['vf'])\n        if len(fps) > 0:\n            self._frame_fps = float(fps[0])\n        self._ffmpeg_audio_args = ffmpeg_audio_args or {}\n        self._ffmpeg_audio_args.setdefault('format', 'wav')\n        self._ffmpeg_audio_args.setdefault('ab', DEFAULT_AUDIO_BIT_RATE)\n        self._ffmpeg_audio_args.setdefault('ac', DEFAULT_AUDIO_CHANNELS)\n        self._ffmpeg_audio_args.setdefault('ar', DEFAULT_AUDIO_SAMPLING_RATE)\n        self._ffmpeg_subtitle_args = ffmpeg_subtitle_args or {}\n        self._ffmpeg_subtitle_args.setdefault('map', DEFAULT_SUBTITLE_MAP)\n        self._librosa_load_args = librosa_load_args or {}\n        self._librosa_load_args.setdefault('sr', self._ffmpeg_audio_args['ar'])\n        self._librosa_load_args.setdefault('mono', self._ffmpeg_audio_args['ac'] > 1)\n        self.logger = JinaLogger("
        },
        {
            "comment": "This code extracts video and audio frames from a Document object, storing the extracted data in chunks. It also handles parameters to control extractions, such as ffmpeg_video_args and librosa_load_args. The function loops through each Document object in the docs array, checking for valid URI values and logging information about the received documents.",
            "location": "\"/media/root/Prima/works/vced/docs/src/code/service/videoLoader/video_loader.py\":92-114",
            "content": "            getattr(self.metas, 'name', self.__class__.__name__)\n        ).logger\n    @requests(on='/extract')\n    def extract(self, docs: DocumentArray, parameters: Dict, **kwargs):\n        \"\"\"\n        Load the video from the Document.uri, extract frames and audio. The extracted data are stored in chunks.\n        :param docs: the input Documents with either the video file name or data URI in the `uri` field\n        :param parameters: A dictionary that contains parameters to control\n         extractions and overrides default values.\n        Possible values are `ffmpeg_audio_args`, `ffmpeg_video_args`, `librosa_load_args`. Check out more description in the `__init__()`.\n        For example, `parameters={'ffmpeg_video_args': {'s': '512x320'}`.\n        \"\"\"\n        t1 = time.time()\n        print('video_loader extract', t1)\n        for doc in docs:\n            print(f'video chunks: {len(doc.chunks)}')\n        for doc in docs:\n            self.logger.info(f'received {doc.id}')\n            if doc.uri == '':\n                self.logger.error(f'No uri passed for the Document: {doc.id}')"
        },
        {
            "comment": "The code snippet is part of a video processing function. It checks if the input URI is a data URI, saves it to a temporary directory, and retrieves the file path. If the modality includes 'image', it updates ffmpeg_video_args with additional parameters and converts the video to frames using the _convert_video_uri_to_frames function. The frames are then processed one by one, printing their shape and creating new Document objects for each frame with modality 'image'.",
            "location": "\"/media/root/Prima/works/vced/docs/src/code/service/videoLoader/video_loader.py\":115-137",
            "content": "                continue\n            with tempfile.TemporaryDirectory() as tmpdir:\n                source_fn = (\n                    self._save_uri_to_tmp_file(doc.uri, tmpdir)\n                    if self._is_datauri(doc.uri)\n                    else doc.uri\n                )\n                # extract all the frames video\n                if 'image' in self._modality:\n                    ffmpeg_video_args = deepcopy(self._ffmpeg_video_args)\n                    ffmpeg_video_args.update(parameters.get('ffmpeg_video_args', {}))\n                    frame_tensors = self._convert_video_uri_to_frames(\n                        source_fn, doc.uri, ffmpeg_video_args\n                    )\n                    for idx, frame_tensor in enumerate(frame_tensors):\n                        # print(frame_tensor.shape)\n                        self.logger.debug(f'frame: {idx}')\n                        chunk = Document(modality='image')\n                        # chunk.blob = frame_tensor\n                        max_size = 240\n                        img = Image.fromarray(frame_tensor)"
        },
        {
            "comment": "This code resizes an image and converts it to a numpy array, then adds it as a chunk to the document with metadata like timestamp and video URI if necessary. Additionally, it handles audio chunks if specified in modality.",
            "location": "\"/media/root/Prima/works/vced/docs/src/code/service/videoLoader/video_loader.py\":138-156",
            "content": "                        if img.size[0] > img.size[1]:\n                            width = max_size\n                            height = math.ceil(max_size / img.size[0] * img.size[1])\n                        else:\n                            height = max_size\n                            width = math.ceil(max_size / img.size[1] * img.size[0])\n                        img = img.resize((width, height))\n                        chunk.tensor = np.asarray(img).astype('uint8')\n                        print(chunk.tensor.shape)\n                        # chunk.tensor = np.array(frame_tensor).astype('uint8')\n                        chunk.location = (np.uint32(idx),)\n                        chunk.tags['timestamp'] = idx / self._frame_fps\n                        if self._copy_uri:\n                            chunk.tags['video_uri'] = doc.uri\n                        doc.chunks.append(chunk)\n                # add audio as chunks to the Document, modality='audio'\n                # if 'audio' in self._modality:\n                #     ffmpeg_audio_args = deepcopy(self._ffmpeg_audio_args)"
        },
        {
            "comment": "Code snippet is parsing video URI and extracting audio data from it. It updates ffmpeg_audio_args, librosa_load_args with user parameters. If audio is not None, it creates a new Document object (modality='audio') and stores the extracted audio data and sample rate into it. If copy_uri is True, it also adds the original video URI to the document's tags. Then, it checks if 'text' is included in self._modality and prepares for subtitle extraction.",
            "location": "\"/media/root/Prima/works/vced/docs/src/code/service/videoLoader/video_loader.py\":157-174",
            "content": "                #     ffmpeg_audio_args.update(parameters.get('ffmpeg_audio_args', {}))\n                #     librosa_load_args = deepcopy(self._librosa_load_args)\n                #     librosa_load_args.update(parameters.get('librosa_load_args', {}))\n                #     audio, sr = self._convert_video_uri_to_audio(\n                #         source_fn, doc.uri, ffmpeg_audio_args, librosa_load_args\n                #     )\n                #     if audio is None:\n                #         continue\n                #     chunk = Document(modality='audio')\n                #     chunk.tensor, chunk.tags['sample_rate'] = audio, sr\n                #     if self._copy_uri:\n                #         chunk.tags['video_uri'] = doc.uri\n                #     doc.chunks.append(chunk)\n                # add subtitle ad chunks to the Document, modality='text'\n                # if 'text' in self._modality:\n                #     ffmpeg_subtitle_args = deepcopy(self._ffmpeg_subtitle_args)\n                #     ffmpeg_subtitle_args.update("
        },
        {
            "comment": "This code segment appears to be involved in extracting subtitles from a video file and converting the video URI into frames. It uses FFmpeg arguments to specify how the subtitles should be extracted, and then creates Document objects for each subtitle chunk, including start and end times. The subtitle chunks are added to a document object. Finally, the time taken to execute this function is logged.",
            "location": "\"/media/root/Prima/works/vced/docs/src/code/service/videoLoader/video_loader.py\":175-195",
            "content": "                #         parameters.get('ffmpeg_subtitle_args', {})\n                #     )\n                #     subtitles = self._convert_video_uri_to_subtitle(\n                #         source_fn, ffmpeg_subtitle_args, tmpdir\n                #     )\n                #     for idx, (beg, end, s) in enumerate(subtitles):\n                #         chunk = Document(text=s, modality='text')\n                #         chunk.tags['beg_in_seconds'] = beg\n                #         chunk.tags['end_in_seconds'] = end\n                #         if self._copy_uri:\n                #             chunk.tags['video_uri'] = doc.uri\n                #         chunk.location = (idx,)  # index of the subtitle in the video\n                #         doc.chunks.append(chunk)\n            t2 = time.time()\n            print(t2 - t1, t2)\n    def _convert_video_uri_to_frames(self, source_fn, uri, ffmpeg_args):\n        video_frames = []\n        try:\n            # get width and height\n            video = ffmpeg.probe(source_fn)['streams'][0]"
        },
        {
            "comment": "This code extracts video frames using FFmpeg and resizes them. It takes a source file, applies the specified FFmpeg arguments to convert it into a pipe output, and then converts that output into numpy arrays representing video frames. If frame extraction fails, an error is logged.",
            "location": "\"/media/root/Prima/works/vced/docs/src/code/service/videoLoader/video_loader.py\":196-217",
            "content": "            w, h = ffmpeg_args.get('s', f'{video[\"width\"]}x{video[\"height\"]}').split('x')\n            w = int(w)\n            h = int(h)\n            out, _ = (\n                ffmpeg.input(source_fn)\n                .output('pipe:', **ffmpeg_args)\n                .run(capture_stdout=True, quiet=True)\n            )\n            # w = math.ceil(w / 1)\n            # h = math.ceil(h / 1)\n            # img = Image.frombuffer(\"RGB\", (w, h), out)\n            # print(img.size)\n            video_frames = np.frombuffer(out, np.uint8) #.reshape([-1, h, w, 3])\n            # print(video_frames.shape)\n            video_frames = video_frames.reshape([-1, h, w, 3])\n            # img = Image.fromarray(video_frames)\n            # img = img.resize((math.ceil(img.size[0]/10), math.ceil(img.size[1] / 10)))\n            # print(img.size)\n            # video_frames = np.asarray(img).reshape([-1, h, w, 3])\n            # print(\"v2\",video_frames.shape)\n        except ffmpeg.Error as e:\n            self.logger.error(f'Frame extraction failed, {uri}, {e.stderr}')"
        },
        {
            "comment": "This function is responsible for extracting audio from a video file. It first attempts to use ffmpeg to convert the video into audio, and then tries to load that audio data using librosa library. If any errors occur during this process, they are logged. The function returns the extracted audio data and its sample rate.\n\nIn more detail:\n- Takes a source file and URI as input along with ffmpeg and librosa arguments\n- Attempts to use ffmpeg to convert video into audio using input and output parameters\n- Captures stdout from ffmpeg and uses librosa library to load the audio data\n- If any errors occur during the process, they are logged as an error\n- Returns extracted audio data and its sample rate",
            "location": "\"/media/root/Prima/works/vced/docs/src/code/service/videoLoader/video_loader.py\":219-246",
            "content": "        return video_frames\n    def _convert_video_uri_to_audio(self, source_fn, uri, ffmpeg_args, librosa_args):\n        data = None\n        sample_rate = None\n        try:\n            out, _ = (\n                ffmpeg.input(source_fn)\n                .output('pipe:', **ffmpeg_args)\n                .run(capture_stdout=True, quiet=True)\n            )\n            data, sample_rate = librosa.load(io.BytesIO(out), **librosa_args)\n        except ffmpeg.Error as e:\n            self.logger.error(\n                f'Audio extraction failed with ffmpeg, uri: {uri}, {e.stderr}'\n            )\n        except librosa.LibrosaError as e:\n            self.logger.error(f'Array conversion failed with librosa, uri: {uri}, {e}')\n        finally:\n            return data, sample_rate\n    def _convert_video_uri_to_subtitle(self, source_fn, ffmpeg_args, tmp_dir):\n        subtitle_fn = str(os.path.join(tmp_dir, 'subs.srt'))\n        subtitles = []\n        print(ffmpeg_args)\n        try:\n            out, _ = (\n                ffmpeg.input(source_fn)"
        },
        {
            "comment": "The code snippet is a part of a video loading process. It attempts to extract subtitles using ffmpeg and handles any errors that occur. In case of error, it logs the error message. It also saves a given URI to a temporary file by downloading the content and storing it locally. The `_process_subtitles` function processes an SRT path and can optionally take VTT path and tmp srt path as inputs.",
            "location": "\"/media/root/Prima/works/vced/docs/src/code/service/videoLoader/video_loader.py\":247-274",
            "content": "                .output(subtitle_fn, **ffmpeg_args)\n                .run(capture_stdout=True, quiet=True)\n            )\n            subtitles = self._process_subtitles(Path(subtitle_fn))\n        except ffmpeg.Error as e:\n            self.logger.error(f'Subtitle extraction failed with ffmpeg, {e.stderr}')\n        finally:\n            return subtitles\n    def _save_uri_to_tmp_file(self, uri, tmpdir):\n        req = urllib.request.Request(uri, headers={'User-Agent': 'Mozilla/5.0'})\n        tmp_fn = os.path.join(\n            tmpdir,\n            ''.join([random.choice(string.ascii_lowercase) for i in range(10)])\n            + '.mp4',\n        )\n        with urllib.request.urlopen(req) as fp:\n            buffer = fp.read()\n            binary_fn = io.BytesIO(buffer)\n            with open(tmp_fn, 'wb') as f:\n                f.write(binary_fn.read())\n        return tmp_fn\n    def _process_subtitles(\n        self, srt_path: Path, vtt_path: Path = None, tmp_srt_path: Path = None\n    ):\n        beg = None\n        is_last_cap_complete = True"
        },
        {
            "comment": "This code reads a WebVTT file, filters each caption's text, and appends the start time, end time, and filtered text to the subtitles list if the caption is complete. It also keeps track of previous captions and handles special cases like the last complete caption and incomplete captions.",
            "location": "\"/media/root/Prima/works/vced/docs/src/code/service/videoLoader/video_loader.py\":275-297",
            "content": "        subtitles = []\n        prev_parts = []\n        vtt_fn = self._convert_srt_to_vtt(srt_path, vtt_path, tmp_srt_path)\n        for caption in webvtt.read(vtt_fn):\n            cur_parts = [\n                t\n                for t in filter(lambda x: len(x.strip()) > 0, caption.text.split('\\n'))\n            ]\n            filtered_text = ' '.join(cur_parts)\n            if len(cur_parts) == 1:\n                if cur_parts[0] in prev_parts:\n                    continue\n            if len(cur_parts) > 1:\n                if cur_parts[0] in prev_parts and is_last_cap_complete:\n                    filtered_text = ' '.join(cur_parts[1:])\n            is_cur_complete = True\n            if is_last_cap_complete:\n                beg = caption.start_in_seconds\n            if caption.text.startswith(' \\n') or caption.text.endswith('\\n '):\n                is_cur_complete = False\n            if is_cur_complete:\n                if filtered_text:\n                    subtitles.append((beg, caption.end_in_seconds, filtered_text))"
        },
        {
            "comment": "The code provides functions for handling video subtitles and text files. It determines if a URI is of type \"data\", removes carriage returns from input text files, and converts SRT (SubRip Subtitle) files to VTT format. The functions include `_is_datauri`, `_remove_carriage_return`, and `_convert_srt_to_vtt`.",
            "location": "\"/media/root/Prima/works/vced/docs/src/code/service/videoLoader/video_loader.py\":298-326",
            "content": "            is_last_cap_complete = is_cur_complete\n            prev_parts = cur_parts\n        return subtitles\n    def _is_datauri(self, uri):\n        scheme = urllib.parse.urlparse(uri).scheme\n        return scheme in {'data'}\n    def _remove_carriage_return(self, input_path, output_path=None):\n        result = []\n        with open(input_path, 'rb') as f:\n            for l in f:\n                if l == b'\\r\\n':\n                    continue\n                new_l = l.decode('utf8').replace('\\r\\n', '\\n')\n                new_l = new_l.rstrip('\\n')\n                result.append(new_l)\n        if output_path is None:\n            output_fn = f'{input_path.stem}_no_cr{input_path.suffix}'\n            output_path = input_path.parent / output_fn\n        with open(output_path, 'w') as f:\n            f.write('\\n'.join(result))\n        return output_path\n    def _convert_srt_to_vtt(\n        self, srt_path: Path, vtt_path: Path = None, tmp_srt_path: Path = None\n    ):\n        if vtt_path is None:\n            vtt_path = srt_path.parent / f'{srt_path.stem}.vtt'"
        },
        {
            "comment": "This code attempts to read a file in the .srt format, converts it to .vtt format using webvtt library. If it encounters a malformed caption error, it removes carriage returns from the file and retries conversion. Finally, it saves the result in .vtt format and returns the path.",
            "location": "\"/media/root/Prima/works/vced/docs/src/code/service/videoLoader/video_loader.py\":327-334",
            "content": "        try:\n            result = webvtt.from_srt(srt_path)\n        except webvtt.errors.MalformedCaptionError as e:\n            self.logger.warning('remove carriage returns from the .srt file')\n            srt_path = self._remove_carriage_return(srt_path, tmp_srt_path)\n            result = webvtt.from_srt(srt_path)\n        result.save(output=vtt_path)\n        return vtt_path"
        }
    ]
}