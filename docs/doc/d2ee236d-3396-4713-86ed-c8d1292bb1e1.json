{
    "summary": "The SimpleIndexer class is an Executor extension for efficient Document data storage, indexing/searching with SQLite and CLIP. It includes methods for deleting, updating, and retrieving embeddings via HTTP endpoints. Normalization, cosine similarity calculation, softmax probability return, and a clear method to delete the database are included.",
    "details": [
        {
            "comment": "The code is defining a class called SimpleIndexer that extends the Executor class from the Jina library. It takes in parameters such as pretrained_model_name_or_path, match_args, table_name, traversal_right, traversal_left, and device. This indexer stores all Document data in a DocumentArray and can dump to and load from disk. It is meant to be used as a unified indexer for both indexing and searching purposes.",
            "location": "\"/media/root/Prima/works/vced/docs/src/code/service/customIndexer/executor.py\":0-37",
            "content": "import inspect\nimport os\nfrom typing import Dict, Optional\nfrom jina import DocumentArray, Executor, requests\nfrom jina.logging.logger import JinaLogger\nimport clip\nfrom torch import Tensor\nimport torch\nimport time\nclass SimpleIndexer(Executor):\n    \"\"\"\n    A simple indexer that stores all the Document data together in a DocumentArray,\n    and can dump to and load from disk.\n    To be used as a unified indexer, combining both indexing and searching\n    \"\"\"\n    FILE_NAME = 'index.db'\n    def __init__(\n        self,\n        pretrained_model_name_or_path: str = 'ViT-B/32',\n        match_args: Optional[Dict] = None,\n        table_name: str = 'simple_indexer_table2',\n        traversal_right: str = '@r',\n        traversal_left: str = '@r',\n        device: str = 'cpu',\n        **kwargs,\n    ):\n        \"\"\"\n        Initializer function for the simple indexer\n        To specify storage path, use `workspace` attribute in executor `metas`\n        :param match_args: the arguments to `DocumentArray`'s match function\n        :param table_name: name of the table to work with for the sqlite backend"
        },
        {
            "comment": "This code initializes a class with default parameters, creates a DocumentArray index with customized SQLite storage configuration, sets up a logger and defines default traversal paths. It also loads a pretrained model using the CLIP library without requiring GPU acceleration and assigns them to the class instance variables.",
            "location": "\"/media/root/Prima/works/vced/docs/src/code/service/customIndexer/executor.py\":38-67",
            "content": "        :param traversal_right: the default traversal path for the indexer's\n        DocumentArray\n        :param traversal_left: the default traversal path for the query\n        DocumentArray\n        \"\"\"\n        super().__init__(**kwargs)\n        self._match_args = match_args or {}\n        self._index = DocumentArray(\n            storage='sqlite',\n            config={\n                'connection': os.path.join(self.workspace, SimpleIndexer.FILE_NAME),\n                'table_name': table_name,\n            },\n        )  # with customize config\n        self.logger = JinaLogger(self.metas.name)\n        self.default_traversal_right = traversal_right\n        self.default_traversal_left = traversal_left\n        self.pretrained_model_name_or_path = pretrained_model_name_or_path\n        self.device = device\n        model, preprocessor = clip.load(self.pretrained_model_name_or_path, device=\"cpu\")   # No need to load on cuda\n        self.preprocessor = preprocessor\n        self.model = model\n    @property\n    def table_name(self) -> str:"
        },
        {
            "comment": "Function `index` takes a list of documents and adds them to the index, timing the operation.\nFunction `search` performs a vector similarity search using provided documents, allowing for custom match arguments.",
            "location": "\"/media/root/Prima/works/vced/docs/src/code/service/customIndexer/executor.py\":68-106",
            "content": "        return self._index._table_name\n    @requests(on='/index')\n    def index(\n        self,\n        docs: 'DocumentArray',\n        **kwargs,\n    ):\n        \"\"\"All Documents to the DocumentArray\n        :param docs: the docs to add\n        \"\"\"\n        t1 = time.time()\n        if docs:\n            self._index.extend(docs)\n        t2 = time.time()\n        print(t2 - t1)\n        print(t1)\n        print(t2)\n    @requests(on='/search')\n    def search(\n        self,\n        docs: 'DocumentArray',\n        parameters: Optional[Dict] = None,\n        **kwargs,\n    ):\n        \"\"\"Perform a vector similarity search and retrieve the full Document match\n        :param docs: the Documents to search with\n        :param parameters: the runtime arguments to `DocumentArray`'s match\n        function. They overwrite the original match_args arguments.\n        \"\"\"\n        match_args = (\n            {**self._match_args, **parameters}\n            if parameters is not None\n            else self._match_args\n        )\n        traversal_right = parameters.get("
        },
        {
            "comment": "This code retrieves the 'traversal_left' and 'traversal_right' parameters, filters match_args, and iterates through texts and stored_docs. It checks if any stored document URI is not in doc_ids, skips those, calculates the length of images features, and measures execution times at different points.",
            "location": "\"/media/root/Prima/works/vced/docs/src/code/service/customIndexer/executor.py\":107-128",
            "content": "            'traversal_right', self.default_traversal_right\n        )\n        traversal_left = parameters.get('traversal_left', self.default_traversal_left)\n        match_args = SimpleIndexer._filter_match_params(docs, match_args)\n        # print('in indexer',docs[traversal_left].embeddings.shape, self._index[traversal_right])\n        texts: DocumentArray = docs[traversal_left]\n        stored_docs: DocumentArray = self._index[traversal_right]\n        doc_ids = parameters.get(\"doc_ids\")\n        t1 = time.time()\n        with torch.inference_mode():\n            t1_00 = time.time()\n            for text in texts:\n                result = []\n                text_features = text.embedding\n                text.embedding = None\n                for sd in stored_docs:\n                    if doc_ids is not None and sd.uri not in doc_ids:\n                        continue\n                    images_features = sd.embedding\n                    print('images len',len(images_features))\n                    t1_0 = time.time()"
        },
        {
            "comment": "This code creates tensors from image features, calculates scores between these tensor and text features using the 'score' function, stores results in a list, and prints the time taken for various operations. It also calculates the overall score cost and calls another function 'getMultiRan'.",
            "location": "\"/media/root/Prima/works/vced/docs/src/code/service/customIndexer/executor.py\":129-149",
            "content": "                    tensor_images_features = [Tensor(image_features) for image_features in images_features]\n                    t1_1 = time.time()\n                    for i, image_features in enumerate(tensor_images_features):\n                        tensor = image_features\n                        probs = self.score(tensor, text_features)\n                        result.append({\n                            \"score\": probs[0][0],\n                            \"index\": i,\n                            \"uri\": sd.uri,\n                            \"id\": sd.id\n                        })\n                    t1_2 = time.time()\n                    print(\"tensor cost:\", t1_1 - t1_0)\n                    print(\"part score cost:\", t1_2 - t1_1)\n                    print(t1_0)\n                    print(t1_1)\n                    print(t1_2)\n                t2 = time.time()\n                print('score cost:', t2 - t1)\n                # print(parameters, type(parameters.get(\"thod\")))\n                index_list = self.getMultiRan"
        },
        {
            "comment": "This code calculates the time taken to execute a range search, and populates the tags of each document in the DocumentArray with relevant information. It also defines a function called getMultiRange that takes a result list, threshold value (thod), and maximum count as parameters, and returns a DocumentArray with populated tags for each document.",
            "location": "\"/media/root/Prima/works/vced/docs/src/code/service/customIndexer/executor.py\":149-169",
            "content": "ge(result,0.1 if parameters.get(\"thod\") is None else parameters.get('thod'), parameters.get(\"maxCount\"))\n                t3 = time.time()\n                print('range cost:', t3 - t2)\n                print(t1)\n                print(t1_00)\n                print(t2)\n                print(t3)\n                # print(index_list)\n                docArr = DocumentArray.empty(len(index_list))\n                for i, doc in enumerate(docArr):\n                    doc.tags[\"leftIndex\"] = index_list[i][\"leftIndex\"]\n                    doc.tags[\"rightIndex\"] = index_list[i][\"rightIndex\"]\n                    # print(index_list[i])\n                    doc.tags[\"maxImageScore\"] = float(index_list[i][\"maxImage\"][\"score\"])\n                    doc.tags[\"uri\"] = index_list[i][\"maxImage\"][\"uri\"]\n                    doc.tags[\"maxIndex\"] = index_list[i][\"maxImage\"][\"index\"]\n                # print(docArr)\n                text.matches = docArr\n    def getMultiRange(self, result: list, thod = 0.1, maxCount: int = 10):\n        ignore_range = {}"
        },
        {
            "comment": "This code initializes an empty list called index_list, sets a maximum count as an integer, and then uses a for loop to iterate through the specified range of counts. It retrieves the next maximum item using getNextMaxItem function and appends its corresponding left index, right index, and maxImage data to index_list. If the maxImage's URI is in ignore_range, it updates its corresponding list of indices. Finally, it returns the populated index_list. The getNextMaxItem function iterates through the result list and continues if item's URI is in ignore_range or its index is in ignore_range[item[\"uri\"]].",
            "location": "\"/media/root/Prima/works/vced/docs/src/code/service/customIndexer/executor.py\":170-194",
            "content": "        index_list = []\n        maxCount = int(maxCount)\n        for i in range(maxCount):\n            maxItem = self.getNextMaxItem(result, ignore_range)\n            if maxItem is None:\n                break\n            # print(maxItem[\"score\"])\n            leftIndex, rightIndex, maxImage = self.getRange(maxItem, result, thod, ignore_range)\n            index_list.append({\n                \"leftIndex\": leftIndex,\n                \"rightIndex\": rightIndex,\n                \"maxImage\": maxImage\n            })\n            if maxImage[\"uri\"] in ignore_range:\n                ignore_range[maxImage[\"uri\"]] += list(range(leftIndex, rightIndex + 1))\n            else:\n                ignore_range[maxImage[\"uri\"]] = list(range(leftIndex, rightIndex + 1))\n        # print(ignore_range)\n        return index_list\n    def getNextMaxItem(self, result: list, ignore_range):\n        maxItem = None\n        for item in result:\n            if item[\"uri\"] in ignore_range and item[\"index\"] in ignore_range[item[\"uri\"]]:\n                continue"
        },
        {
            "comment": "This code retrieves the maximum item from a list, then determines the range of an image within that list by iterating through the items. The function takes into account an optional ignore_range parameter and a threshold value (thod) to determine where the leftIndex and rightIndex lie in relation to maxIndex.",
            "location": "\"/media/root/Prima/works/vced/docs/src/code/service/customIndexer/executor.py\":195-221",
            "content": "            if maxItem is None:\n                maxItem = item\n            if item[\"score\"] > maxItem[\"score\"]:\n                maxItem = item\n        return maxItem\n    def getRange(self, maxItem, result: list, thod = 0.1, ignore_range = None):\n        maxImageScore = maxItem[\"score\"]\n        maxImageUri = maxItem[\"uri\"]\n        maxIndex = maxItem[\"index\"]\n        leftIndex = maxIndex\n        rightIndex = maxIndex\n        has_ignore_range = ignore_range is not None\n        d_result = list(filter(lambda x: x[\"uri\"] == maxImageUri, result))\n        for i in range(maxIndex):\n            prev_index = maxIndex - 1 - i\n            if has_ignore_range and prev_index in ignore_range:\n                break\n            # print(maxImageScore, thod, maxImageUri, maxIndex)\n            if d_result[prev_index][\"score\"] >= maxImageScore - thod:\n                leftIndex = prev_index\n            else:\n                break\n        for i in range(maxIndex+1, len(d_result)):\n            if has_ignore_range and i in ignore_range:"
        },
        {
            "comment": "The code is implementing a custom indexer for document retrieval. It starts by normalizing image and text features, calculating cosine similarity as logits, and returning softmax probabilities. The main function filters match parameters and adjusts result ranges accordingly.",
            "location": "\"/media/root/Prima/works/vced/docs/src/code/service/customIndexer/executor.py\":222-249",
            "content": "                break\n            if d_result[i][\"score\"] >= maxImageScore - thod:\n                rightIndex = i\n            else:\n                break\n        if (rightIndex - leftIndex) > 60:\n            return self.getRange(maxItem, result, thod/2, ignore_range)\n        return leftIndex, max(rightIndex, leftIndex + 10), d_result[maxIndex]\n    def score(self, image_features, text_features):\n        logit_scale = self.model.logit_scale.exp()\n        # normalized features\n        image_features = image_features / image_features.norm(dim=1, keepdim=True)\n        text_features = text_features / text_features.norm(dim=1, keepdim=True)\n        # cosine similarity as logits\n        logits_per_image = logit_scale * image_features @ text_features.t()\n        probs = logits_per_image.softmax(dim=-1).cpu().detach().numpy()\n        # print(\" img Label probs:\", probs)\n        return probs\n    @staticmethod\n    def _filter_match_params(docs, match_args):\n        # get only those arguments that exist in .match\n        args = set(inspect.getfullargspec(docs.match).args)"
        },
        {
            "comment": "This code defines methods for a custom indexer that handles deleting, updating, and retrieving embeddings of documents. The delete method removes entries from the index by ID, update adds or updates documents based on ID, and fill_embedding retrieves embeddings of documents by ID. These methods are accessible via HTTP endpoints \"/delete\", \"/update\", and \"/fill_embedding\".",
            "location": "\"/media/root/Prima/works/vced/docs/src/code/service/customIndexer/executor.py\":250-282",
            "content": "        args.discard('self')\n        match_args = {k: v for k, v in match_args.items() if k in args}\n        return match_args\n    @requests(on='/delete')\n    def delete(self, parameters: Dict, **kwargs):\n        \"\"\"Delete entries from the index by id\n        :param parameters: parameters to the request\n        \"\"\"\n        deleted_ids = parameters.get('ids', [])\n        if len(deleted_ids) == 0:\n            return\n        del self._index[deleted_ids]\n    @requests(on='/update')\n    def update(self, docs: DocumentArray, **kwargs):\n        \"\"\"Update doc with the same id, if not present, append into storage\n        :param docs: the documents to update\n        \"\"\"\n        for doc in docs:\n            try:\n                self._index[doc.id] = doc\n            except IndexError:\n                self.logger.warning(\n                    f'cannot update doc {doc.id} as it does not exist in storage'\n                )\n    @requests(on='/fill_embedding')\n    def fill_embedding(self, docs: DocumentArray, **kwargs):\n        \"\"\"retrieve embedding of Documents by id"
        },
        {
            "comment": "This code defines a method named `clear` which clears the database when invoked with the '/clear' endpoint. It utilizes an index (self._index) and accesses document embeddings based on their respective IDs in the provided DocumentArray.",
            "location": "\"/media/root/Prima/works/vced/docs/src/code/service/customIndexer/executor.py\":284-292",
            "content": "        :param docs: DocumentArray to search with\n        \"\"\"\n        for doc in docs:\n            doc.embedding = self._index[doc.id].embedding\n    @requests(on='/clear')\n    def clear(self, **kwargs):\n        \"\"\"clear the database\"\"\"\n        self._index.clear()"
        }
    ]
}